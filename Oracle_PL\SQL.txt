本文主题：主要讲解PL\SQL中游标、触发器、存储过程和函数的使用

游标：
游标分为隐式游标和显示游标

隐式游标用于处理INSERT、UPDATE、和SELECT INTO语句。
小知识：游标会自动与每一个DML语句关联。游标具有ROWCOUNT的属性，可以告诉我们有多少行受到了影响，例如：
SET SERVEROUTPUT ON
BEGIN
  UPDATE STUDENT SET FIRST_NAME = 'A' WHERE FIRST_NAME LIKE 'B%';
  DBMS_OUTPUT.PUT_LINE(SQL%ROWCOUNT);
END;

显式游标可以为我们提供更多的编程控制
使用过程：
1、声明：将游标初始化到内存
2、打开：声明的游标可以被打开了，分配内存
3、读取：开始检索数据，这是读取游标的过程
4、关闭：释放分配的内存

游标中的属性：
%NOTFOUND：布尔属性，如果前一个fetch没有拿到一行，就返回true，否则返回false
%FOUND:和上面的返回相反咯
%ROWCOUNT:在那个时刻，从游标中读取到的值
%ISOPEN：布尔属性，如果游标是打开的，就返回true，反正返回false

直接给出实例吧(ps:游标的命名约定一般是C_CURSORNAME, 读取记录一般是R_CURSORNAME)：
SET SERVEROUTPUT ON
DECLARE
  CURSOR C_COUNTS
  IS
    SELECT ID, NAME FROM TABLE_NAME WHERE COLUMN LIKE 'xx%';
  R_COUNTS C_COUNTS%ROWTYPE;
BEGIN
  OPEN C_COUNTS;
  LOOP
    FETCH C_COUNTS INTO R_COUNTS;
    EXIT WHEN C_COUNTS%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE('NAME: ' || R_COUNTS.NAME || '; COUNT: ' || C_COUNTS%ROWCOUNT);
  END LOOP;
  CLOSE C_COUNTS;
END;
/

懒得再写这么多了，下面的一些知识点也很重要，其中包括高级游标的使用，自己去看书或者百度吧：
使用LOOP循环获取游标的时候，需要有退出条件，上面使用的是%NOTFUND属性，也可以使用%FUND配合IF ELSE EXIT来实现退出;
还可以使用for循环来获取游标中的记录，此时打开、读取和关闭游标都是被隐式处理的;
游标可以嵌套使用;
声明游标的时候可以使用参数;
在嵌套游标里使用参数，具有父游标，子游标的层次关系;
使用FOR UPDATE游标;
在游标中使用WHERE CURRENT。



触发器：
触发器事件可以是以下任意一种：
1、对数据库表执行的DML语句
2、由特定用户针对某个模式或任何用户执行的DDL语句
3、系统事件，如启动或关闭数据库
4、用户事件，如登录和注销行为

创建一个触发器时的一些限制：
1、触发器不能发出事务控制语句，如commit、rollback、savepoint。触发器被触发时，他的所有操作都是事务的一部分。当事务被提交或者回滚时，该触发器内的操作也会被提交或回滚。不过，有一种例外：包含自治事务的触发器
2、任何由触发器调用的函数或者过程都不能发出事务控制语句，例外：包含自治事务
3、不允许在触发器里声明LONG或LONG RAW变量

触发器中表示伪记录的行：
:NEW 
:OLD

举个例子吧：




