深入理解java线程池之ThreadPoolExecutor类详解
为了提高程序效率，我们经常会使用线程，如果在使用的时候创建，用完后就销魂，这样实现起来很简单，
但如果并发线程很多，频繁的创建和销毁线程会浪费很多时间和资源。
为了避免这种损耗，java中使用线程池来管理线程，池初始化时会创建一定数量的线程，需要的时候从中获取，用完之后不会销毁，而是放回池中。
本文以java.uitl.concurrent.ThreadPoolExecutor为例，对源码进行解读。
先看类的一些重要属性：
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
private static final int RUNNING    = -1 << COUNT_BITS;
private static final int SHUTDOWN   =  0 << COUNT_BITS;
private static final int STOP       =  1 << COUNT_BITS;
private static final int TIDYING    =  2 << COUNT_BITS;
private static final int TERMINATED =  3 << COUNT_BITS;
private final ReentrantLock mainLock = new ReentrantLock();	//线程池的状态锁
private volatile int corePoolSize;		//线程池大小
private volatile int maximumPoolSize;	//线程池最大能容忍的线程数量
//private volatile int  poolSize;       	//线程池中当前的线程数
private int largestPoolSize;   			//记录线程池中曾经出现过的最大线程数
private volatile long keepAliveTime;	//表示线程没有任务执行时最多保持多久时间会终止。
private volatile RejectedExecutionHandler handler;	//任务拒绝策略
private final BlockingQueue<Runnable> workQueue;	//阻塞队列，用来存储等待执行的任务
private volatile ThreadFactory threadFactory;		//线程工厂，主要用来创建线程

ctl变量保证了操作具有原子性，他保存了所有有效线程的数量和他们的状态。
RUNNING:  Accept new tasks and process queued tasks
SHUTDOWN: Don't accept new tasks, but process queued tasks
STOP:     Don't accept new tasks, don't process queued tasks,
          and interrupt in-progress tasks
TIDYING:  All tasks have terminated, workerCount is zero,
          the thread transitioning to state TIDYING
          will run the terminated() hook method
TERMINATED: terminated() has completed
这里强调一下corePoolSize, maximumPoolSize和largestPoolSize的区别
一个工厂里面有10个工人，一人一次只能做一个任务，如果有人空闲下来就可以再被分配任务，
如果现在过来的任务数量超出了工人的数量，就将这些任务放到一个队列房间里面存储，如果存储的数量达到了上线，
就需要采取补救措施，于是就雇佣了4个临时工人。
当任务增加的速度比较缓慢的时候，队列房间里出现了空闲的位置存放多余的任务，那4个临时工就会被辞掉。
这里corePoolSize就是10，maximumPoolSize就是14，largestPoolSize表示线程池曾经出现过的最大线程数，与线程容量无关，只作为记录，队列房间的存储数量就是队列的容量。

接下来看一下ThreadPoolExecutor的构造方法：
public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue){...};
public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory){...}
public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, RejectedExecutionHandler handler) {...}
public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) {...}

下面是构造方法的源码：
public ThreadPoolExecutor(int corePoolSize,
						  int maximumPoolSize,
						  long keepAliveTime,
						  TimeUnit unit,
						  BlockingQueue<Runnable> workQueue,
						  ThreadFactory threadFactory,
						  RejectedExecutionHandler handler) {
	if (corePoolSize < 0 || maximumPoolSize <= 0 || maximumPoolSize < corePoolSize || keepAliveTime < 0)
		throw new IllegalArgumentException();
	if (workQueue == null || threadFactory == null || handler == null)
		throw new NullPointerException();
	this.acc = System.getSecurityManager() == null ? null : AccessController.getContext();
	this.corePoolSize = corePoolSize;
	this.maximumPoolSize = maximumPoolSize;
	this.workQueue = workQueue;
	this.keepAliveTime = unit.toNanos(keepAliveTime);
	this.threadFactory = threadFactory;
	this.handler = handler;
}
TimeUnit是keppAliveTime的时间单位，可以为TimeUnit.DAYS;TimeUnit.HOURS;等等，TimeUnit是一个简单枚举类型。
BlockingQueue作为存放任务的队列接口，一般有如下几种实现：
	ArrayBlockingQueue;
	LinkedBlockingQueue;
	SynchronousQueue;
	PriorityBlockingQueue;
	DelayedWorkQueue;
ThreadFactory 线程工厂，用来创建线程，默认调用Executors.defaultThreadFactory()
RejectedExecutionHandler表示当拒绝处理任务时的策略，有如下几种方式；
	ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 这个为默认值
	ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 
	ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
	ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务

创建线程池后，默认情况下池中是没有线程的，只有当任务到来时才会创建，用完之后再放回池中，如果需要立刻创建可以调用方法：
public int prestartAllCoreThreads() {		//预创建corePoolSize个数的线程
	int n = 0;
	while (addWorker(null, true))
		++n;
	return n;
}
或者
public boolean prestartCoreThread() {		//预创建一个线程
	return workerCountOf(ctl.get()) < corePoolSize && addWorker(null, true);
}

ThreadPoolExecutor类继承自AbstractExecutorService抽象类
AbstractExecutorService抽象类实现了ExecutorService接口
ExecutorService接口继承自Executor接口
Executor中只有一个方法：
	void execute(Runnable command);
	
execute()是ThreadPoolExecutor中的核心方法，调用此方法就是向线程池提交一个任务，让线程池中的空闲线程去执行该任务，
类中还有很多其他方法，有兴趣的可以去查阅API，接下来主要分析execute()的源码。

public void execute(Runnable command) {
	if (command == null)
		throw new NullPointerException();
	int c = ctl.get();							//workerCountOf(c)得到池中当前线程数量，isRunning(c)得到表示当前线程是否是RUNNING状态
	if (workerCountOf(c) < corePoolSize) {		//如果当前线程的数量小于核心线程池的值
		if (addWorker(command, true))			//创建一个线程去执行当前任务，如果执行成功就返回true。
			return;								//任务执行成功后返回。
		c = ctl.get();							//执行失败就把当前线程池的状态和线程数量拿到。
	}
	if (isRunning(c) && workQueue.offer(command)) {		//如果当前池中的线程数量已经达到了核心池的数量就不会再继续新建线程去执行任务，而是去判断当前线程池是否还处于RUNNING状态，并将任务放到队列中。
		int recheck = ctl.get();						//这里再次获取池的信息，为了让下一步 double check 状态，这是为什么？因为。。。
		if (! isRunning(recheck) && remove(command))	//如果当前线程不是处于RUNNING的状态，并且成功从队列中移除指定任务，就采取相应的拒绝策略
			reject(command);
		else if (workerCountOf(recheck) == 0)			//否则如果当前线程处于RUNNING状态或者从队列在移除任务失败，并且当前线程数量为0，就执行if中的语句
			addWorker(null, false);
	}
	else if (!addWorker(command, false))	//如果线程不是RUNNING状态或者任务加入到队列中失败（即队列已经满了），就创建继续创建线程执行该任务
		reject(command);					//如果执行任务失败就采取相应的拒绝策略
}

简单总结一下这个方法：
当一个任务过来的时候，如果池中的线程数还没有达到核心线程数，就会新建线程去处理这个任务，
当数量达到了核心线程数，再有任务进来的时候就会放到队列中去（会有工作线程去不断访问队列并将任务拿出来给空闲线程去执行），
如果任务增长的速度太快将队列放满了，还有任务又过来了，就会再继续创建线程去执行这些任务（这里创建的线程就是上面的临时工，它们是大于codePoolSize，小于maximumPoolSize）。
