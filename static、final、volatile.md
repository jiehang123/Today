# static

> static 变量

static变量也称作静态变量，静态变量和非静态变量的区别是：  
静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。  
而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。  
static是不允许用来修饰局部变量  
静态成员变量虽然独立于对象，但是不代表不可以通过对象去访问，所有的静态方法和静态变量都可以通过对象访问（只要访问权限足够），下面有举例

> static 方法

静态方法不依赖于任何对象就可以进行访问  
静态方法是没有this的，因为它不依附于任何对象  
在静态方法中不能访问类的非静态成员变量和非静态成员方法, 反之可以  

> static 代码块

用来形成静态代码块以优化程序性能。
static块可以置于类中的任何地方，类中可以有多个static块。  
在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次

> static 类

不能访问外部类的非静态成员，只能访问外部类的静态成员  
静态内部类可以单独初始化

> static 静态导包

一般我们导入一个类都用 import com…..ClassName;而静态导入是这样：import static com…..ClassName.\*;这里的多了个static，还有就是类名ClassName后面多了个.\* ，意思是导入这个类里的静态方法。当然，也可以只导入某个静态方法，只要把 .\* 换成静态方法名就行了。然后在这个类中，就可以直接用方法名调用静态方法，而不必用ClassName.方法名
 的方式来调用。
 
 
 # transient
  1、一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。  
  2、transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。  
  3、被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。  
  **疑问：** transient使用细节——被transient关键字修饰的变量真的不能被序列化吗？  
参考：https://www.cnblogs.com/lanxuezaipiao/p/3369962.html


# volatile
禁止指令重排序  
关于内存原子性，可见性，有序性的知识自己百度
